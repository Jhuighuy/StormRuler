// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< //
// Copyright (C) 2021 Oleg Butakov
//
// Permission is hereby granted, free of charge, to any person
// obtaining a copy of this software and associated documentation
// files (the "Software"), to deal in the Software without
// restriction, including without limitation the rights  to use,
// copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following
// conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
// OTHER DEALINGS IN THE SOFTWARE.
// >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> //

#define _USE_MATH_DEFINES 1

#include <Storm/Utils/Banner.hpp>

#include <Storm/Bittern/FastVector.hpp>
#include <Storm/Bittern/Mat.hpp>

#include <Storm/Mallard/IoTetgen.hpp>
#include <Storm/Mallard/IoVtk.hpp>
#include <Storm/Mallard/MeshUnstructured.hpp>
#include <Storm/Mallard/Shape.hpp>
// #include <Storm/Bittern/Matrix.hpp>
#include <Storm/Feathers/SkunkFvSolver.hpp>

#include <algorithm>
#include <cstring>
#include <fstream>
#include <math.h>
#include <ranges>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

using namespace Storm;
using namespace Storm::Feathers;

inline std::string my_to_string(size_t i) {
  std::string s = std::to_string(i);
  std::string z(5 - s.size(), '0');
  return z + s;
}

template<std::ranges::input_range Range>
auto ForEachSum(Range&& r, auto x, auto f) {
  std::ranges::for_each(r, [&](auto y) { x += f(y); });
  return x;
}

void save_vtk(auto& mesh, const char* path,
              const std::vector<sFieldDesc>& fields) {
  std::ofstream file(path);
  file << std::setprecision(std::numeric_limits<real_t>::digits10 + 1);
  file << "# vtk DataFile Version 2.0" << std::endl;
  file << "# Generated by Feathers/StormRuler/Mesh2VTK" << std::endl;
  file << "ASCII" << std::endl;
  file << "DATASET UNSTRUCTURED_GRID" << std::endl;

  file << "POINTS " << mesh.num_nodes() << " double" << std::endl;
  std::ranges::for_each(mesh.nodes(), [&](auto node) {
    const auto& pos = node.position();
    file << pos.x << " " << pos.y << " " << 0.0 << std::endl;
  });
  file << std::endl;

  size_t const sumNumCellAdjNodes =
      ForEachSum(mesh.interior_cells(), size_t(0),
                 [](auto cell) { return cell.nodes().size() + 1; });
  file << "CELLS " << mesh.num_cells({}) << " " << sumNumCellAdjNodes
       << std::endl;
  std::ranges::for_each(mesh.interior_cells(), [&](auto cell) {
    file << cell.nodes().size() << " ";
    cell.for_each_node(
        [&](NodeIndex node_index) { file << node_index << " "; });
    file << std::endl;
  });
  file << std::endl;

  file << "CELL_TYPES " << mesh.num_cells({}) << std::endl;
  std::ranges::for_each(mesh.interior_cells(),
                        [&](auto cell) { file << "5" << std::endl; });
  file << std::endl;

  file << "CELL_DATA " << mesh.num_cells({}) << std::endl;
  for (const sFieldDesc& field : fields) {
    file << "SCALARS " << field.name << " double 1" << std::endl;
    file << "LOOKUP_TABLE default" << std::endl;
    std::ranges::for_each(mesh.interior_cells(), [&](auto cell) {
      file << (*field.scalar)[cell][field.var_index] << std::endl;
    });
  }
  file << std::endl;
} // Mesh::save_vtk

int main(int argc, char** argv) {
  print_banner();

  UnstructuredMesh<2, 2, VovTable> mesh1{};
  read_mesh_from_tetgen(mesh1, "test/mesh/step.1.");

  auto mesh = std::make_shared<UnstructuredMesh<2, 2, CsrTable>>();
  mesh->assign(std::move(mesh1));

  STORM_INFO_("mesh has {} edges", mesh->num_edges());
  STORM_INFO_("mesh has {} faces", mesh->num_faces());
  STORM_INFO_("mesh has {} cells", mesh->num_cells());
  STORM_INFO_("mesh loaded");

  CellField<Mesh, real_t, 5> uc(mesh->num_cells());
  CellField<Mesh, real_t, 5> up(mesh->num_cells());
  for (size_t cell_ind = 0; cell_ind < mesh->num_cells(); ++cell_ind) {
    std::array<real_t, 5> q{2.0, 1.0, 1.0, 0.0, 0.0};
    // std::array<real_t, 5> q{1.4, 1.0, 3.0, 0.0, 0.0};
    MhdHydroVars v({}, nullptr, q.data());
    v.make_cons(5, uc[CellIndex<Mesh>{cell_ind}].data());
  }
  real_t dt = 1e-4;

  MhdFvSolverT<tGasPhysics> solver(mesh);
  const size_t freq = 200;
  save_vtk(*mesh, ("out/fields-" + my_to_string(0) + ".vtk").c_str(),
           {{"rho", 0, &uc}});
  real_t tt = 0.0;
  {
    for (size_t l = 1; l <= 2000000; ++l) {
      solver.calc_step(dt, uc, up);
      if (l % freq == 0) {
        std::cout << l / freq << "\t" << tt << "\t" << std::endl;
        save_vtk(*mesh,
                 ("out/fields-" + my_to_string(l / freq) + ".vtk").c_str(),
                 {{"rho", 0, &uc}});
      }

      uc.swap(up);
    }
  }

  return 0;
}
